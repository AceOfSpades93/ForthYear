package search;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.PriorityQueue;

public class PuzzleSolver {
	private PuzzleBoard initial;
	private PuzzleBoard destination;
	private List<PuzzleBoard> sol = new ArrayList<>();
	
	public PuzzleSolver(PuzzleBoard board) {
		initial = board.clone();
		
		if (initial.isSolvable()) {
			solve();
		}
		
		int[][] dest = new int[initial.getBoardSize()][initial.getBoardSize()];
		
		for (int i = 0; i < initial.getBoardSize(); ++i) {
			for (int j = 0; j < initial.getBoardSize(); ++j) {
				dest[i][j] = i * initial.getBoardSize() + j + 1;
			}
		}
		
		destination = new PuzzleBoard(dest);
	}
	
	public boolean isSolvable() {
		return initial.isSolvable();
	}
	
	public Iterable<PuzzleBoard> solution() {
		return sol;
	}
	
	private void solve() {
		if (initial.equals(destination)) {
			sol.add(initial.clone());
			return;
		}
		
		PriorityQueue<Node> pQ = new PriorityQueue<>();
		HashSet<PuzzleBoard> wasExtended = new HashSet<>();
		
		pQ.add(new Node(initial, 0));
		
		while (!pQ.isEmpty()) {
			Node b = pQ.peek();
			
			if (b.v.equals(destination)) {
				break;
			}
			
			pQ.remove();
			
			if (wasExtended.contains(b.v)) {
				continue;
			}
			
			wasExtended.add(b.v);
			
			for(PuzzleBoard newB: b.v.neighbors()) {
				pQ.add(new Node(newB, b.cost + 1 + newB.hammilton(), b));
			}
		}
		
		if (!pQ.isEmpty()) {
			getPath(pQ.remove());
		}
	}
	
	private void getPath(Node end) {
		for (; null != end; end = end.prev) {
			sol.add(0, end.v);
		}
	}

	private static class Node implements Comparable<Node> {
		int cost;
		Node prev = null;
		PuzzleBoard v = null; 
		
		public Node(PuzzleBoard v, int cost) {
			this.v = v;
			this.cost = cost;
		}
		
		public Node(PuzzleBoard v, int cost, Node prev) {
			this(v, cost);
			this.prev = prev;
		}

		@Override
		public int compareTo(Node o) {
			return (cost - o.cost);
		}
		
	};
}
